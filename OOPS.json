{
    "Basic": [
        {
            "question": "Who invented OOP?",
            "a": "Andrea Ferro",
            "b": "Adele Goldberg",
            "c": "Alan Kay",
            "d": "Dennis Ritchie",
            "ans": "ans3",
            "explanation": "Alan Kay invented OOP, Andrea Ferro was a part of SmallTalk Development. Dennis invented C++ and Adele Goldberg was in team to develop SmallTalk but Alan actually had got rewarded for OOP."
        },
        {
            "question": "Which is not a feature of OOP in general definitions?",
            "a": "Efficient Code",
            "b": "Code reusability",
            "c": "Modularity",
            "d": "Duplicate/Redundant data",
            "ans": "ans4",
            "explanation": "Duplicate/Redundant data is dependent on programmer and hence can’t be guaranteed by OOP. Code reusability is done using inheritance. Modularity is supported by using different code files and classes. Codes are more efficient because of features of OOP."
        },
        {
            "question": "Which was the first purely object oriented programming language developed?",
            "a": "Kotlin",
            "b": "SmallTalk",
            "c": "Java",
            "d": "C++",
            "ans": "ans2",
            "explanation": "SmallTalk was the first programming language developed which was purely object oriented. It was developed by Alan Kay. OOP concept came into the picture in 1970’s."
        },
        {
            "question": "When OOP concept did first came into picture?",
            "a": "1980's",
            "b": "1995",
            "c": "1970's",
            "d": "1993",
            "ans": "ans3",
            "explanation": "OOP first came into picture in 1970’s by Alan and his team. Later it was used by some programming languages and got implemented successfully, SmallTalk was first language to use pure OOP and followed all rules strictly."
        },
        {
            "question": "Which feature of OOP indicates code reusability?",
            "a": "Abstraction",
            "b": "Ploymorphism",
            "c": "Encapsulation",
            "d": "Inheritance",
            "ans": "ans4",
            "explanation": "Inheritance indicates the code reusability. Encapsulation and abstraction are meant to hide/group data into one element. Polymorphism is to indicate different tasks performed by a single entity."
        },
        {
            "question": "Which header file is required in C++ to use OOP?",
            "a": "OOP can be used without any header file",
            "b": "stdlib.h",
            "c": "iostream.h",
            "d": "stdio.h",
            "ans": "ans1",
            "explanation": "We need not include any specific header file to use OOP concept in C++, only specific functions used in code need their respective header files to be included or classes should be defined if needed."
        },
        {
            "question": "Why Java is Partially OOP language?",
            "a": "It allows code to be written outside classes",
            "b": "It supports usual declaration of primitive data types",
            "c": "It does not support pointers",
            "d": "It doesn’t support all types of inheritance",
            "ans": "ans2",
            "explanation": "As Java supports usual declaration of data variables, it is partial implementation of OOP. Because according to rules of OOP, object constructors must be used, even for declaration of variables."
        },
        {
            "question": "Which among the following doesn’t come under OOP concept?",
            "a": "Data hiding",
            "b": "message passing",
            "c": "Platform independent",
            "d": "Data binding",
            "ans": "ans3",
            "explanation": "Platform independence is not feature of OOP. C++ supports OOP but it’s not a platform independent language. Platform independence depends on the programming language."
        },
        {
            "question": "Which is the correct syntax of inheritance?",
            "a": "class base_classname :access derived_classname{ /*define class body*/ };",
            "b": "class derived_classname : access base_classname{ /*define class body*/ };",
            "c": "class derived_classname : base_classname{ /*define class body*/ };",
            "d": "class base_classname : derived_classname{ /*define class body*/ }",
            "ans": "ans2",
            "explanation": "Firstly, keyword class should come, followed by the derived class name. Colon is must followed by access in which base class has to be derived, followed by the base class name. And finally the body of class. Semicolon after the body is also must."
        },
        {
            "question": "Which feature of OOP is indicated by the following code? \n \n class student{  int marks;  }; \n class topper:public student{  int age;  topper(int age){ this.age=age; } };",
            "a": "Encapsulation and Inheritance",
            "b": "Inheritance and Ploymorphism",
            "c": "Ploymorphism",
            "d": "Inheritance",
            "ans": "ans1",
            "explanation": "Encapsulation is indicated by use of classes. Inheritance is shown by inheriting the student class into topper class. Polymorphism is not shown here because we have defined the constructor in the topper class but that doesn’t mean that default constructor is overloaded."
        },
        {
            "question": "The feature by which one object can interact with another object is _____________",
            "a": "Message reading",
            "b": "Message Passing",
            "c": "Data transfer",
            "d": "Data binding",
            "ans": "ans2",
            "explanation": "The interaction between two object is called the message passing feature. Data transfer is not a feature of OOP. Also, message reading is not a feature of OOP."
        },
        {
            "question": "Which among the following, for a pure OOP language, is true?",
            "a": "The language should follow at least 1 feature of OOP",
            "b": "The language must follow only 3 features of OOP",
            "c": "The language must follow all the rules of OOP",
            "d": "The language should follow 3 or more features of OOP",
            "ans": "ans3",
            "explanation": "The language must follow all the rules of OOP to be called a purely OOP language. Even if a single OOP feature is not followed, then it’s known to be a partially OOP language."
        },
        {
            "question": "How many types of access specifiers are provided in OOP (C++)?",
            "a": "4",
            "b": "3",
            "c": "2",
            "d": "1",
            "ans": "ans2",
            "explanation": "Only 3 types of access specifiers are available. Namely, private, protected and public. All these three can be used according to the need of security of members."
        },
        {
            "question": "In multilevel inheritance, which is the most significant feature of OOP used?",
            "a": "Code efficiency",
            "b": "Code readability",
            "c": "Flexibility",
            "d": "Code reusability",
            "ans": "ans4",
            "explanation": "The classes using multilevel inheritance will use the code in all the subsequent subclasses if available. Hence the most significant feature among the options given is code reusability. This feature is generally intended to use the data values and reuse the redundant functions."
        },
        {
            "question": "What is encapsulation in OOP?",
            "a": "It is a way of combining various data members and member functions that operate on those data members into a single unit",
            "b": "It is a way of combining various data members and member functions into a single unit which can operate on any data",
            "c": "It is a way of combining various data members into a single unit",
            "d": "It is a way of combining various member functions into a single unit",
            "ans": "ans1",
            "explanation": "It is a way of combining both data members and member functions, which operate on those data members, into a single unit. We call it a class in OOP generally. This feature have helped us modify the structures used in C language to be upgraded into class in C++ and other languages."
        }
    ],
    "Intermediate": [
        {
            "question": "Which keyword is used to declare virtual functions?",
            "a": "virt",
            "b": "virtually",
            "c": "virtual",
            "d": "anonymous",
            "ans": "ans3",
            "explanation": "The virtual keyword is used to declare virtual functions. Anonymous keyword is used with classes and have a different meaning. The virtual functions are used to call the intended function of the derived class."
        },
        {
            "question": "What happens if non static members are used in static member function?",
            "a": "Executes fine",
            "b": "compile time error",
            "c": "Executes ifthat member function is not used",
            "d": "Runtime error",
            "ans": "ans2",
            "explanation": "There must be specific memory space allocated for the data members before the static member functions uses them. But the space is not reserved if object is not declared. Hence only if static members are not used, it leads to compile time error."
        },
        {
            "question": "What is friend member functions in C++?",
            "a": "Non-member functions which have access to all the members (including private) of a class",
            "b": "Member function which doesn’t have access to private members",
            "c": "Member function which can modify any data of a class",
            "d": "Member function which can access all the members of a class",
            "ans": "ans1",
            "explanation": "A non-member function of a class which can access even the private data of a class is a friend function. It is an exception on access to private members outside the class. It is sometimes considered as a member functions since it has all the access that a member function in general have."
        },
        {
            "question": "Where is the memory allocated for the objects?",
            "a": "Cache",
            "b": "ROM",
            "c": "HDD",
            "d": "RAM",
            "ans": "ans4",
            "explanation": "The memory for the objects or any other data is allocated in RAM initially. This is while we run a program all the memory allocation takes place in some RAM segments. Arrays in heap and local members in stack etc."
        },
        {
            "question": "Which of the following best describes member function overriding?",
            "a": "Member functions having the same name in derived class only",
            "b": "Member functions having the same name and different signature inside main function",
            "c": "Member functions having the same name in base and derived classes",
            "d": "Member functions having the same name in base class only",
            "ans": "ans3",
            "explanation": "The member function which is defined in base class and again in the derived class, is overridden by the definition given in the derived class. This is because the preference is given more to the local members. When derived class object calls that function, definition from the derived class is used."
        },
        {
            "question": "Encapsulation and abstraction differ as ____________",
            "a": "Hiding and hiding respectively",
            "b": "Binding and Hiding respectively",
            "c": "Hiding and Binding respectively",
            "d": "Can be used anyway",
            "ans": "ans2",
            "explanation": "Abstraction is hiding the complex code. For example, we directly use cout object in C++ but we don’t know how is it actually implemented. Encapsulation is data binding, as in, we try to combine a similar type of data and functions together."
        },
        {
            "question": "Which feature of OOP is exhibited by the function overriding?",
            "a": "Polymorphism",
            "b": "Encapsulation",
            "c": "Abstraction",
            "d": "Inheritance",
            "ans": "ans1",
            "explanation": "The polymorphism feature is exhibited by function overriding. Polymorphism is the feature which basically defines that same named functions can have more than one functionalities."
        },
        {
            "question": "How to access the private member function of a class?",
            "a": "Using class address",
            "b": "Using object of class",
            "c": "Using object pointer",
            "d": "Using address of member function",
            "ans": "ans4",
            "explanation": "Even the private member functions can be called outside the class. This is possible if address of the function is known. We can use the address to call the function outside the class."
        },
        {
            "question": "Which keyword should be used to declare static variables?",
            "a": "const",
            "b": "common",
            "c": "static",
            "d": "stat",
            "ans": "ans3",
            "explanation": "The keyword used to declare static variables is static. This is must be used while declaring the static variables. The compiler can make variables static if and only if they are mentioned with static keyword."
        },
        {
            "question": "Which is correct syntax for declaring pointer to object?",
            "a": "*className objectName;",
            "b": "className* objectName;",
            "c": "className objectName();",
            "d": "className objectName;",
            "ans": "ans2",
            "explanation": "The syntax must contain * symbol after the className as the type of object. This declares an object pointer. This can store address of any object of the specified class."
        },
        {
            "question": "If data members are private, what can we do to access them from the class object?",
            "a": "Private data members can never be accessed from outside the class",
            "b": "Create public member functions to access those data members",
            "c": "Create private member functions to access those data members",
            "d": "Create protected member functions to access those data members",
            "ans": "ans2",
            "explanation": "We can define public member functions to access those private data members and get their value for use or alteration. They can’t be accessed directly but is possible to be access using member functions. This is done to ensure that the private data doesn’t get modified accidentally."
        },
        {
            "question": "Which among the following is not a necessary condition for constructors?",
            "a": "Its name must be same as that of class",
            "b": "It must not have any return type",
            "c": "It must contain a definition body",
            "d": "It can contains arguments",
            "ans": "ans3",
            "explanation": "Constructors are predefined implicitly, even if the programmer doesn’t define any of them. Even if the programmer declares a constructor, it’s not necessary that it must contain some definition."
        },
        {
            "question": "Object being passed to a copy constructor ___________",
            "a": "Must not be mentioned in parameter list",
            "b": "Must be passed with integer type",
            "c": "Must be passed by value",
            "d": "Must be passed by reference",
            "ans": "ans4",
            "explanation": "This is mandatory to pass the object by reference. Otherwise, the object will try to create another object to copy its values, in turn a constructor will be called, and this will keep on calling itself. This will cause the compiler to give out of memory error."
        },
        {
            "question": "If in multiple inheritance, class C inherits class B, and Class B inherits class A. In which sequence are their destructors called if an object of class C was declared?",
            "a": "~A() then ~B() then ~C()",
            "b": "~C() then ~A() then ~B()",
            "c": "~C() then ~B() then ~A()",
            "d": "~B() then ~C() then ~A()",
            "ans": "ans3",
            "explanation": "The destructors are always called in the reverse order of how the constructors were called. Here class A constructor would have been created first if Class C object is declared. Hence class A destructor is called at last."
        },
        {
            "question": "Instance of which type of class can’t be created?",
            "a": "Parent class",
            "b": "Abstract class",
            "c": "Anonymous class",
            "d": "Nested class",
            "ans": "ans2",
            "explanation": "Instance of abstract class can’t be created as it will not have any constructor of its own, hence while creating an instance of class, it can’t initialize the object members. Actually the class inheriting the abstract class can have its instance because it will have implementation of all members."
        }
    ],
    "Advanced": [
        {
            "question": "Which among the following is called first, automatically, whenever an object is created?",
            "a": "Class",
            "b": "Constructor",
            "c": "New",
            "d": "Trigger",
            "ans": "ans2",
            "explanation": "Constructors are the member functions which are called automatically whenever an object is created. It is a mandatory functions to be called for an object to be created as this helps in initializing the object to a legal initial value for the class."
        },
        {
            "question": "Which among the following is not a necessary condition for constructors?",
            "a": "Its name must be same as that of class",
            "b": "It must not have any return type",
            "c": "It must contain a definition body",
            "d": "It can contains arguments",
            "ans": "ans3",
            "explanation": "Constructors are predefined implicitly, even if the programmer doesn’t define any of them. Even if the programmer declares a constructor, it’s not necessary that it must contain some definition."
        },
        {
            "question": "Which among the following is correct?",
            "a": "class student{ public: int student(){} };",
            "b": "class student{ public: void student (){} };",
            "c": "class student{ public: student{}{} };",
            "d": "class student{ public: student(){} };",
            "ans": "ans4",
            "explanation": "The constructors must not have any return type. Also, the body may or may not contain any body. Defining default constructor is optional, if you are not using any other constructor."
        },
        {
            "question": "In which access should a constructor be defined, so that object of the class can be created in any function?",
            "a": "Public",
            "b": "Protected",
            "c": "Private",
            "d": "PAny access specifier will work",
            "ans": "ans1",
            "explanation": "Constructor function should be available to all the parts of program where the object is to be created. Hence it is advised to define it in public access, so that any other function is able to create objects."
        },
        {
            "question": "How many types of constructors are available for use in general (with respect to parameters)?",
            "a": "2",
            "b": "3",
            "c": "4",
            "d": "5",
            "ans": "ans1",
            "explanation": "Two types of constructors are defined generally, namely, default constructor and parameterized constructor. Default constructor is not necessary to be defined always."
        },
        {
            "question": "What does memory allocation for objects mean?",
            "a": "Actual creation and memory allocation for object members",
            "b": "Creation of member functions",
            "c": "Creation of data members for a class",
            "d": "Actual creation and data declaration for object members",
            "ans": "ans1",
            "explanation": "The memory allocated for the object members indicates actual creation of the object members. This is known as memory allocation for object."
        },
        {
            "question": "Where is the memory allocated for the objects?",
            "a": "HDD",
            "b": "Cache",
            "c": "RAM",
            "d": "ROM",
            "ans": "ans3",
            "explanation": "The memory for the objects or any other data is allocated in RAM initially. This is while we run a program all the memory allocation takes place in some RAM segments. Arrays in heap and local members in stack etc."
        },
        {
            "question": "When is the memory allocated for an object?",
            "a": "At declaration of object",
            "b": "At compile time",
            "c": "When object constructor is called",
            "d": "When object is initialized to another object",
            "ans": "ans3",
            "explanation": "The object memory allocation takes place when the object constructor is called. Declaration of an object doesn’t mean that memory is allocated for its members. If object is initialized with another object, it may just get a reference to the previously created object."
        },
        {
            "question": "Using new is type safe as _______________________",
            "a": "It require to be specified with type of data",
            "b": "It doesn’t require to be specified with type of data",
            "c": "It requires the name of data",
            "d": "It allocated memory for the data",
            "ans": "ans2",
            "explanation": "The new is type safe because we don’t have to specify the type of data that have to be allocated with memory. We can directly use it with data name. Name of the data doesn’t matter though for type of memory allocation though."
        },
        {
            "question": "Which of the following function can be used for dynamic memory allocation of objects?",
            "a": "malloc()",
            "b": "calloc()",
            "c": "create()",
            "d": "malloc() and calloc()",
            "ans": "ans4",
            "explanation": "The malloc() function can be used to allocate dynamic memory for objects. Function calloc() can also be use. These functions differ in the way they allocate memory for objects."
        },
        {
            "question": "Which among the following best describes the Inheritance?",
            "a": "Copying the code already written",
            "b": "Using the code already written once",
            "c": "Using already defined functions in programming language",
            "d": "Using the data and functions into derived segment",
            "ans": "ans4",
            "explanation": "It can only be indicated by using the data and functions that we use in derived class, being provided by parent class. Copying code is nowhere similar to this concept, also using the code already written is same as copying. Using already defined functions is not inheritance as we are not adding any of our own features."
        },
        {
            "question": "How many basic types of inheritance are provided as OOP feature?",
            "a": "4",
            "b": "3",
            "c": "2",
            "d": "1",
            "ans": "ans1",
            "explanation": "There are basically 4 types of inheritance provided in OOP, namely, single level, multilevel, multiple and hierarchical inheritance. We can add one more type as Hybrid inheritance but that is actually the combination any types of inheritance from the 4 basic ones."
        },
        {
            "question": "Which among the following best defines single level inheritance?",
            "a": "A class inheriting a derived class",
            "b": "A class inheriting a base class",
            "c": "A class inheriting a nested class",
            "d": "A class which gets inherited by 2 classes",
            "ans": "ans2",
            "explanation": "A class inheriting a base class defines single level inheritance. Inheriting an already derived class makes it multilevel inheritance. And if base class is inherited by 2 other classes, it is multiple inheritance."
        },
        {
            "question": "Which among the following is correct for multiple inheritance?",
            "a": "class student{public: int marks;}s; class stream{int total;}; class",
            "b": "class student{int marks;}; class stream{ }; class topper: public student{ };",
            "c": "class student{int marks;}; class stream:public student{ };",
            "d": "class student{ }; class stream{ }; class topper{ }",
            "ans": "ans1",
            "explanation": "Class topper is getting derived from 2 other classes and hence it is multiple inheritance. Topper inherits class stream and class student publicly and hence can use its features. If only few classes are defined, there we are not even using inheritance (as in option class student{ }; class stream{ }; class topper{ };)."
        },
        {
            "question": "Which programming language doesn’t support multiple inheritance?",
            "a": "C++ and Java",
            "b": "C and C++",
            "c": "Java and SmallTalk",
            "d": "Java",
            "ans": "ans4",
            "explanation": "Java doesn’t support multiple inheritance. But that feature can be implemented by using the interfaces concept. Multiple inheritance is not supported because of diamond problem and similar issues."
        }
    ]
    
}
    

    